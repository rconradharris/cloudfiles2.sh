#!/bin/bash
# bashfiles - Manage CloudFiles via the command-line

BF_VERSION=0.4
BF_PROG=bashfiles
BF_DEFAULT_CONTENT_TYPE=application/octet-stream
BF_CONFIG_DIR=~/.$BF_PROG
BF_ENDPOINTS_DIR=$BF_CONFIG_DIR/endpoints
BF_CHECKSUM_PROGRESS_MIN_SIZE=10485760 # 10 MB
BF_TMPLINK_SELF_DESTRUCT=3600 # secs

OPT_ALL=0
OPT_CONTENT_TYPE=
OPT_DIR=
OPT_ENDPOINT=default
OPT_FORCE=0
OPT_INPUT=
OPT_OUTPUT=
OPT_QUIET=0
OPT_EXPIRATION=0

#############################################################################
#                                                                           #
#                               Bashfiles                                   #
#                                                                           #
#############################################################################


function bf_help() {
    cat <<'EOF'
SYNOPSIS

    bashfiles [options] [commands] [container] [object-names]

DESCRIPTION

    `bashfiles` is a utility for working with Rackspace CloudFiles via the
    command-line. `bashfiles` has minimal dependencies, requiring only bash,
    curl, and a few other POSIX utilities.

    You can pass settings to `bashfiles` via environment variables or by
    defining a configuration file located at `~/.bashfiles`.

OPTIONS

    -a      All-mode (for `get` will fetch all objects)
    -b      Print bash completion script
    -d      Directory to use
    -e      Use endpoint
    -f      Force
    -h      Print help
    -i      Input filename (- for stdin)
    -o      Output filename (- for stdout)
    -q      Quiet mode
    -t      Set Content-Type for upload
    -v      Print version
    -x      Object expiration in seconds

COMMANDS

    cdn     Manage CDN

                disable <region> <container>

                        Disable the CDN for a container

                enable <region> <container>

                        Enable the CDN for a container

                ls <region>

                        List CDN enabled containers in a region

                regions

                        List available CF CDN regions

                stat <region> <container>

                        Show CDN information for container

    cp      Server-side object copy

            -f Overwrite destination object if exists

    endpoint Manage endpoints

                add     <endpoint>

                        Add endpoint

                default [endpoint]

                        Show or set default endpoint

                ls
                        List all endpoints

                rm      <endpoint>

                        Remove endpoint

                show    <endpoint>

                        Show endpoint settings

    get     <container> [objects]

            Download one or more files

            -a Get all objects in a container
            -d Download files to this directory
            -f Overwrite local file if exists
            -o Output to different filename, - for stdout

    ls      <container> [path]

            List all containers or contents of a specific container

            For CloudFiles, you can list the contents of pseudo-hierarchical
            folders by supplying `path` prefix, e.g.
            `ls mycontainer folder1/folder2`

    mkdir   Create a container

    mv      Server-side object move

            -f Overwrite destination object if exists

    put     Upload file

            -f Overwrite remote object if exists
            -i Input from different filename, - for stdin
            -t Set Content-Type for upload
            -x Delete object after this number of seconds

    rm      Remove object

    rmdir   Remove container

            -f Clear container before removing it

    stat    Account, container, or object information

    tmplink <object>

            Upload a file and return a CDN link to it. The file will self
            destruct in one hour.

            -f Overwrite remote object if exists
            -i Input from different filename, - for stdin
            -t Set Content-Type for upload

SETTINGS

    CF_USER         CloudFiles username
    CF_API_KEY      CloudFiles API Key
    CF_AUTH_URL     CloudFiles authentication URL
    CF_SERVICENET   Use Rackspace's ServiceNET network
    CF_INSECURE     Disable SSL certificate verification
    CF_SEGMENT_SIZE Size in bytes of large-file segments (5GB default)

FILES

    ~/.bashfiles/endpoints/*

AUTHORS

    Rick Harris

BUGS

    Report to https://github.com/rconradharris/bashfiles
EOF
    exit 0
}


function bf_bash_completion() {
    cat <<'EOF'
# Search array1 for any element in array2. Stop on first match. -1 on not
# found.
function _bf_match() {
    declare -a array1=("${!1}")
    declare -a array2=("${!2}")

    local i=0
    while [[ $i -lt ${#array1[@]} ]]; do
        local j=0
        while [[ $j -lt ${#array2[@]} ]]; do
            if [[ ${array1[i]} == ${array2[j]} ]]; then
                echo $i
                return
            fi
            let j++
        done
        let i++
    done

    echo '-1'
}


function _bf_completer() {
    COMPREPLY=()

    local OPTIONS=(-a -b -d -e -f -h -i -o -q -t -v -x)
    local COMMANDS=(cdn cp endpoint get ls mkdir mv put rm rmdir stat tmplink)
    local ENDPOINT_COMMANDS=(add default ls rm show)

    local cmd=
    local container_idx=
    local container_fname=
    local object_fname=
    local opts=

    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    local endpoint=default

    local ENDPOINT_OPTIONS=(-e)
    local endpoint_idx=`_bf_match COMP_WORDS[@] ENDPOINT_OPTIONS[@]`
    if [[ $endpoint_idx -ne -1 ]]; then
        endpoint=${COMP_WORDS[endpoint_idx+1]}
    fi

    local BF_CONFIG_DIR=~/.bashfiles
    local BF_ENDPOINTS_DIR=$BF_CONFIG_DIR/endpoints
    local BF_COMPLETION_DIR=$BF_CONFIG_DIR/completion/$endpoint

    local cmd_idx=`_bf_match COMP_WORDS[@] COMMANDS[@]`
    if [[ $cmd_idx -ne -1 ]]; then
        cmd=${COMP_WORDS[cmd_idx]}
        container_idx=`expr $cmd_idx + 1`
        container_fname=$BF_COMPLETION_DIR/container-names
        object_fname=$BF_COMPLETION_DIR/${COMP_WORDS[container_idx]}-object-names
    fi

    if [[ $prev == '-e' && -d $BF_ENDPOINTS_DIR ]]; then
        opts=`ls $BF_ENDPOINTS_DIR | tr '\n' ' '`
    elif [[ $prev == '-i' ]]; then
        COMPREPLY=($(compgen -f $cur))
        return
    elif [[ $cmd_idx -eq -1 && ${cur:0:1} == '-' ]]; then
        # Option (no command yet, starts with -)
        opts="${OPTIONS[@]}"
    elif [[ $cmd_idx -eq -1 ]]; then
        # Command (no command yet, anything else)
        opts="${COMMANDS[@]}"
    elif [[ $cmd == 'endpoint' ]]; then
        if [[ $prev == 'default' || $prev == 'rm' || $prev == 'show' ]]; then
            if [[ -d $BF_ENDPOINTS_DIR ]]; then
                opts=`ls $BF_ENDPOINTS_DIR | grep -v ^default$ | tr '\n' ' '`
            fi
        else
            opts="${ENDPOINT_COMMANDS[@]}"
        fi
    elif [[ $COMP_CWORD -eq $container_idx && -r $container_fname ]]; then
        # Containers (after command)
        opts=`cat $container_fname | tr '\n' ' '`
    elif [[ $cmd == 'put' ]]; then
        # put completes to filenames not object-names
        COMPREPLY=($(compgen -f $cur))
        return
    elif [[ $cmd == 'ls' ]]; then
        # ls doesn't complete to object-names
        return
    elif [[ -r $object_fname ]]; then
        # Everything else completes to a list of object-names
        opts=`cat $object_fname | tr '\n' ' '`
    fi

    COMPREPLY=($(compgen -W "$opts" -- $cur))
}


complete -F _bf_completer bashfiles
EOF
    exit 0
}


function bf_log() {
    if [[ $OPT_QUIET -eq 0 ]]; then
        echo "$@" >&2
    fi
}


function bf_warn() {
    echo "warning: $@" >&2
}


function bf_die() {
    echo "error: $@" >&2
    exit 1
}


function bf_version() {
    echo $BF_VERSION
    exit 0
}


function bf_usage() {
    echo "usage: $BF_PROG [-abdefhqstv] $@" >&2
    exit 1
}


function bf_general_usage() {
    bf_usage "<cdn|cp|endpoint|get|ls|mkdir|mv|put|rm|rmdir|stat|tmplink>" \
             " [container] [object-name]"
}


function bf_ask() {
    local question=$1

    read -p "$question "
    echo $REPLY
}


function bf_ask_required() {
    # NOTE: this function should not be spawned in a subshell b/c it has the
    # side-effect of exiting on an empty reply. This is why we have to return
    # the result by `eval` instead of `echo`ing from a subshell
    local var=$1
    local question=$2
    local reply=`bf_ask "$question"`
    if [[ -z $reply ]]; then
        echo 'Aborted' >&2
        exit 1
    fi
    eval $var="'$reply'"
}


function bf_ask_with_default() {
    local default=$1
    local question=$2

    local reply=`bf_ask "$question"`

    if [[ -z $reply ]]; then
        reply=$default
    fi

    echo "$reply"
}


function bf_ask_yes_no() {
    local default=$1
    local question=$2
    local ret=
    local hint=

    if [[ $default == 'Y' || $default == 'y' ]]; then
        hint="[Y/n]"
    else
        hint="[y/N]"
    fi

    local reply=`bf_ask_with_default "$default" "$question $hint?"`
    if [[ $reply == 'Y' || $reply == 'y' ]]; then
        ret=1
    else
        ret=0
    fi

    echo $ret
}


function bf_md5() {
    local filename=$1

    local size=`bf_size $filename`
    local cmd=

    # Provide checksum progress using `pv` if `pv` is present and we're above
    # the minimum size cut-off
    hash pv > /dev/null 2>&1
    if [[ $? -eq 0 && $size -ge BF_CHECKSUM_PROGRESS_MIN_SIZE ]]; then
        cmd="pv $filename | "
    else
        cmd="cat $filename | "
    fi

    if [[ `uname` == "Darwin" ]]; then
        cmd="${cmd}md5 -q"
    else
        cmd="${cmd}md5sum | cut -d' ' -f1"
    fi

    echo $(eval $cmd)
}


function bf_urlencode() {
    # http://gimi.name/snippets/urlencode-and-urldecode-for-bash-scripting-using-sed/
    echo "$1" | sed -e 's/%/%25/g;s/ /%20/g;s/ /%09/g;s/!/%21/g;s/"/%22/g;' \
                    -e 's/#/%23/g;s/\$/%24/g;s/\&/%26/g;s/'\''/%27/g;'\
                    -e 's/(/%28/g;s/)/%29/g;s/\*/%2a/g;s/+/%2b/g;'\
                    -e 's/,/%2c/g; s/-/%2d/g; s/\./%2e/g; s/:/%3a/g;'\
                    -e 's/;/%3b/g; s//%3e/g; s/?/%3f/g; s/@/%40/g;'\
                    -e 's/\[/%5b/g; s/\\/%5c/g; s/\]/%5d/g; s/\^/%5e/g;'\
                    -e 's/_/%5f/g; s/`/%60/g; s/{/%7b/g; s/|/%7c/g;'\
                    -e 's/}/%7d/g; s/~/%7e/g; s/      /%09/g;'
}


function bf_mktemp() {
    if [[ `uname` == "Darwin" ]]; then
        echo `mktemp -t $BF_PROG`
    else
        echo `mktemp -t $BF_PROG.XXXXXXXXX`
    fi
}


function bf_size() {
    local filename=$1

    if stat -c 2>&1 | grep -q illegal; then
        # Mac OS X
        echo `stat -f%z ${filename}`
    else
        # Linux
        echo `stat -c%s ${filename}`
    fi
}


function bf_compute_num_blocks() {
    local total_size=$1
    local block_size=$2

    local nblocks=$((total_size / $block_size))

    if [[ $((total_size % $block_size)) -gt 0 ]]; then
        let nblocks++
    fi

    echo $nblocks
}


function bf_autodetect_filetype() {
    local filename=$1
    echo `file --brief --mime $filename`
}


function bf_save_endpoint_config_interactive() {
    if [[ `bf_ask_yes_no n 'Save settings'` -eq 1 ]]; then
        mkdir -p `dirname $BF_ENDPOINT_CONFIG`
        touch $BF_ENDPOINT_CONFIG
        cf_save_endpoint_config
    fi
}


function bf_init() {
    BF_ENDPOINT_CONFIG=$BF_ENDPOINTS_DIR/$OPT_ENDPOINT
    BF_COMPLETION_DIR=$BF_CONFIG_DIR/completion/$OPT_ENDPOINT

    # Load from file
    if [[ -r $BF_ENDPOINT_CONFIG ]]; then
        source $BF_ENDPOINT_CONFIG
    fi

    # Interactive
    cf_load_endpoint_config_interactive
    if [[ $? -ne 0 ]]; then
        return
    fi

    bf_save_endpoint_config_interactive
}


#############################################################################
#                                                                           #
#                               Commands                                    #
#                                                                           #
#############################################################################


function cmd_cdn_disable() {
    local region=$1
    local container=$2

    if [[ -z $region ]] || [[ -z $container ]]; then
        bf_usage 'cdn disable <region> <container>'
    fi

    bf_init

    cf_cdn_disable $region $container
}


function cmd_cdn_enable() {
    local region=$1
    local container=$2

    if [[ -z $region ]] || [[ -z $container ]]; then
        bf_usage 'cdn enable <region> <container>'
    fi

    bf_init

    cf_cdn_enable $region $container
}


function cmd_cdn_ls() {
    local region=$1

    if [[ -z $region ]]; then
        bf_usage 'cdn ls <region>'
    fi

    bf_init

    local tmp_file=`bf_mktemp`
    cf_cdn_ls $region "$tmp_file"
    cat $tmp_file
    rm $tmp_file
}


function cmd_cdn_regions() {
    echo dfw - Dallas/Ft. Worth
    echo ord - Chicago
    echo lon - London
    echo syd - Sydney
    echo iad - Northern Virginia
    echo hkg - Hong King
}


function cmd_cdn_stat() {
    local region=$1
    local container=$2
    local tmp_file=`bf_mktemp`

    if [[ -z $region ]] || [[ -z $container ]]; then
        bf_usage 'cdn stat <region> <container>'
    fi

    bf_init

    cf_cdn_stat $region $container "$tmp_file"
    cat $tmp_file
    rm $tmp_file
}


function cmd_cdn() {
    local subcommand=$1
    shift
    case $subcommand in
        disable) cmd_cdn_disable  $@;;
        enable)  cmd_cdn_enable   $@;;
        ls)      cmd_cdn_ls       $@;;
        regions) cmd_cdn_regions  $@;;
        stat)    cmd_cdn_stat     $@;;
        *)       bf_usage 'cdn [disable|enable|ls|regions|stat]';;
    esac
}


function cmd_cp() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    if [[ -z $src_container || -z $src_obj_name
                            || -z $dst_container \
                            || -z $dst_obj_name ]]; then
        bf_usage 'cp <src-container> <src-object-name>' \
                 ' <dst-container> <dst-object-name>'
    fi

    bf_init

    if [[ $OPT_FORCE -ne 1 ]]; then
        cf_assert_objects_missing $dst_container $dst_obj_name
    fi

    cf_cp $src_container $src_obj_name $dst_container $dst_obj_name
}


function cmd_default_endpoint() {
    if [[ -e $BF_ENDPOINTS_DIR/default ]]; then
        basename `readlink $BF_ENDPOINTS_DIR/default`
    else
        echo ""
    fi
}


function cmd_endpoint_add() {
    local endpoint=$1

    if [[ -z $endpoint ]]; then
        bf_usage 'endpoint add <endpoint>'
    fi

    if [[ $endpoint == default ]]; then
        bf_die "endpoint cannot be named 'default'"
    fi

    if [[ -e $BF_ENDPOINTS_DIR/$endpoint ]]; then
        bf_die "endpoint '$endpoint' already exists"
    fi

    OPT_ENDPOINT=$endpoint
    bf_init

    # If only one endpoint, make it the default
    if [[ `cmd_endpoint_ls | wc -l` -eq 1 ]]; then
        cmd_endpoint_default `cmd_endpoint_ls`
    fi
}


function cmd_endpoint_default() {
    local endpoint=$1
    if [[ -z $endpoint ]]; then
        local default=`cmd_default_endpoint`
        if [[ -n $default ]]; then
            echo $default
        else
            bf_die 'no default endpoint set'
        fi
        exit 0
    fi
    if [[ ! -e $BF_ENDPOINTS_DIR/$endpoint ]]; then
        bf_die "endpoint '$endpoint' doesn't exist"
    fi
    if [[ -e $BF_ENDPOINTS_DIR/default ]]; then
        rm $BF_ENDPOINTS_DIR/default
    fi
    echo "Setting default endpoint to '$endpoint'"
    ln -s $BF_ENDPOINTS_DIR/$endpoint $BF_ENDPOINTS_DIR/default
}


function cmd_endpoint_ls() {
    local default=`cmd_default_endpoint`
    for endpoint in `ls $BF_ENDPOINTS_DIR`; do
        if [[ -n $endpoint && $endpoint == $default ]]; then
            echo $endpoint [default]
        elif [[ $endpoint != default ]]; then
            echo $endpoint
        fi
    done
}


function cmd_endpoint_rm() {
    local endpoint=$1
    if [[ -z $endpoint ]]; then
        bf_usage 'endpoint rm <endpoint>'
    fi
    if [[ $endpoint == default ]]; then
        bf_die "cannot remove 'default' endpoint directly, instead remove what default points to"
    fi
    if [[ ! -e $BF_ENDPOINTS_DIR/$endpoint ]]; then
        bf_die "endpoint '$endpoint' doesn't exist"
    fi

    local default=`cmd_default_endpoint`
    if [[ -n $default && $endpoint == $default ]]; then
        rm $BF_ENDPOINTS_DIR/default
    fi
    rm $BF_ENDPOINTS_DIR/$endpoint

    local completion_dir=$BF_CONFIG_DIR/completion/$endpoint
    if [[ -d $completion_dir ]]; then
        rm $completion_dir/*
        rmdir $completion_dir
    fi

    # If only one endpoint left, make it the default
    if [[ `cmd_endpoint_ls | wc -l` -eq 1 ]]; then
        cmd_endpoint_default `cmd_endpoint_ls`
    fi
}


function cmd_endpoint_show() {
    local endpoint=$1
    if [[ -z $endpoint ]]; then
        bf_usage 'endpoint show <endpoint>'
    fi
    if [[ ! -e $BF_ENDPOINTS_DIR/$endpoint ]]; then
        bf_die "endpoint '$endpoint' doesn't exist"
    fi

    cat $BF_ENDPOINTS_DIR/$endpoint
}


function cmd_endpoint() {
    local subcommand=$1
    shift
    case $subcommand in
        add)     cmd_endpoint_add       $@;;
        default) cmd_endpoint_default   $@;;
        ls)      cmd_endpoint_ls        $@;;
        rm)      cmd_endpoint_rm        $@;;
        show)    cmd_endpoint_show      $@;;
        *)       bf_usage 'endpoint [add|default|ls|rm|show]';;
    esac
}


function cmd_get() {
    local container=$1
    shift
    local obj_names=$@

    if [[ $OPT_ALL -eq 1 ]]; then
        if [[ -n $obj_names ]]; then
            bf_die "-a cannot be used with specific object names"
        fi
        if [[ -n $OPT_OUTPUT ]]; then
            bf_die "-o cannot be used with -a"
        fi
    else
        if [[ -z $container || -z $obj_names && $OPT_ALL -ne 1 ]]; then
            bf_usage 'get <container> [object-names]'
        fi
        if [[ -n $OPT_OUTPUT && $# -gt 1 ]]; then
            bf_die "-o can only be used to download a single file"
        fi
    fi

    bf_init

    cf_get $container $obj_names
}


function cmd_ls() {
    local container=$1
    local path=$2
    local tmp_file=`bf_mktemp`

    bf_init

    cf_ls "$container" "$path" "$tmp_file"

    cat $tmp_file

    # Refresh bash-completion cache
    mkdir -p $BF_COMPLETION_DIR
    if [[ -z "$container" ]]; then
        mv $tmp_file $BF_COMPLETION_DIR/container-names
    elif [[ -n "$path" ]]; then
        # Since folder contents is a subset of total container contents, we
        # need to append not replace the listed objects
        cat $tmp_file >> $BF_COMPLETION_DIR/$container-object-names
        rm $tmp_file
    else
        mv $tmp_file $BF_COMPLETION_DIR/$container-object-names
    fi
}


function cmd_mkdir() {
    local containers=$@

    if [[ -z $containers ]]; then
        bf_usage 'mkdir <containers>'
    fi

    bf_init

    cf_mkdir $containers
}


function cmd_mv() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    if [[ -z $src_container || -z $src_obj_name
                            || -z $dst_container \
                            || -z $dst_obj_name ]]; then
        bf_usage 'mv <src-container> <src-object-name>' \
                 ' <dst-container> <dst-object-name>'
    fi

    bf_init

    if [[ $OPT_FORCE -ne 1 ]]; then
        cf_assert_objects_missing $dst_container $dst_obj_name
    fi

    cf_mv $src_container $src_obj_name $dst_container $dst_obj_name
}


function cmd_put() {
    local container=$1
    shift
    local obj_names=$@

    if [[ -z $container || -z $obj_names ]]; then
        bf_usage 'put <container> <object-names>'
    fi

    if [[ -n $OPT_INPUT && $# -gt 1 ]]; then
        bf_die "-i can only be used to upload a single file"
    fi

    bf_init

    if [[ $OPT_FORCE -ne 1 ]]; then
        cf_assert_objects_missing $container $obj_names
    fi

    cf_put $container $obj_names
}


function cmd_rm() {
    local container=$1
    shift
    local obj_names=$@

    if [[ -z $container || -z $obj_names ]]; then
        bf_usage 'rm <container> <object-names>'
    fi

    bf_init

    cf_rm $container $obj_names
}


function cmd_rmdir() {
    local containers=$@

    if [[ -z $containers ]]; then
        bf_usage 'rmdir <containers>'
    fi

    bf_init

    cf_rmdir $containers
}


function cmd_stat() {
    local container=$1
    shift
    local obj_names=$@

    # NOTE: No arg checking because we can accept any number of arguments:
    #
    #    0 - Account statistics
    #    1 - Container statistics
    # >= 2 - Object statistics

    bf_init

    cf_stat $container "$obj_names"
}


function cmd_tmplink() {
    local obj_name=$1

    if [[ -z $obj_name ]]; then
        bf_usage 'tmplink <object-name>'
    fi

    bf_init
    cf_auth

    if [[ -z $CF_TMPLINK_CONTAINER ]]; then
        bf_ask_required 'CF_TMPLINK_CONTAINER' \
                        'CloudFiles Temporary Link (tmplink) Container:'
        bf_save_endpoint_config_interactive
    fi

    if [[ $OPT_FORCE -ne 1 ]]; then
        cf_assert_objects_missing $CF_TMPLINK_CONTAINER $obj_name
    fi

    local region=`cf_cdn_find_region_for_container $CF_TMPLINK_CONTAINER`
    if [[ -z $region ]]; then
        bf_die "could not find CDN region for container, have you enabled CDN?"
    fi

    local orig_expiration=$OPT_EXPIRATION
    OPT_EXPIRATION=$BF_TMPLINK_SELF_DESTRUCT
    cf_put $CF_TMPLINK_CONTAINER $obj_name
    OPT_EXPIRATION=$orig_expiration

    # Get (and print) CDN URL for object
    local tmp_file=`bf_mktemp`
    cf_cdn_stat $region $CF_TMPLINK_CONTAINER "$tmp_file"
    grep -i X-Cdn-Ssl-Uri < $tmp_file | cut -d' ' -f2 \
                                      | tr -d '\r' \
                                      | sed -e "s/$/\/$obj_name/"
    rm $tmp_file
}


#############################################################################
#                                                                           #
#                          CloudFiles Storage                               #
#                                                                           #
#############################################################################


CF_CONST_ZERO_MD5=d41d8cd98f00b204e9800998ecf8427e
CF_DEFAULT_AUTH_URL_US=https://auth.api.rackspacecloud.com/v1.0
CF_DEFAULT_AUTH_URL_UK=https://lon.auth.api.rackspacecloud.com/v1.0
CF_DEFAULT_SEGMENT_SIZE=5368709120
CF_DD_BLOCK_SIZE=1024


function cf_check_ok() {
    local code=$1

    if [[ $code -lt 200 || $code -gt 299 ]]; then
        bf_die "Invalid response code: $code"
    fi
}


function cf_curl() {
    local url=$1
    shift

    if [[ $CF_INSECURE -eq 1 ]]; then
        local curl_opts=--insecure
    else
        local curl_opts=
    fi

    curl $curl_opts --fail "$@" "$url"
}


# Returns http_code in the CF_CURL_RETURN_CODE global
function cf_curl_return_code {
    local tmp_file=`bf_mktemp`
    cf_curl "$@" --write-out '%{http_code}' > $tmp_file
    CF_CURL_RETURN_CODE=`cat $tmp_file`
    rm $tmp_file
}


function cf_auth() {
    if [[ -n $CF_AUTH_TOKEN ]]; then
        return
    fi

    local tmp_headers=`bf_mktemp`

    if [[ -z $CF_AUTH_URL ]]; then
        CF_AUTH_URL=$CF_DEFAULT_AUTH_URL_US
    fi

    cf_curl_return_code ${CF_AUTH_URL} --silent \
                                       --dump-header $tmp_headers \
                                       --header "X-Auth-Key: $CF_API_KEY" \
                                       --header "X-Auth-User: $CF_USER"

    if [[ $CF_CURL_RETURN_CODE = 000 ]]; then
        bf_die "Unable to authenticate to CloudFiles, possible SSL cert error"
    fi

    cf_check_ok $CF_CURL_RETURN_CODE

    CF_AUTH_TOKEN=$(cat $tmp_headers | grep ^X-Auth-Token \
                                     | sed 's/.*: //' \
                                     | tr -d "\r\n")

    CF_STORAGE_URL=$(cat $tmp_headers | grep ^X-Storage-Url \
                                      | sed 's/.*: //' \
                                      | tr -d "\r\n")

    if [[ -z $CF_AUTH_TOKEN || -z $CF_STORAGE_URL ]]; then
        bf_die "Unable to authenticate to CloudFiles"
    fi

    # Handle servicenet
    if [[ $CF_SERVICENET -eq 1 ]]; then
        CF_STORAGE_URL=${CF_STORAGE_URL/https:\/\//https://snet-}
        CF_STORAGE_URL=${CF_STORAGE_URL/http:\/\//http://snet-}
    fi

    rm $tmp_headers
}


function cf_request() {
    local url=$1
    shift

    cf_auth
    cf_curl "$CF_STORAGE_URL/$url" \
            --header "X-Auth-Token: $CF_AUTH_TOKEN" \
            "$@"
}


# Code is returned in CF_CURL_RETURN_CODE global
function cf_request_return_code() {
    local url=$1
    shift

    cf_auth
    cf_curl_return_code "$CF_STORAGE_URL/$url" \
                        --header "X-Auth-Token: $CF_AUTH_TOKEN" \
                        "$@"
}


function cf_request_check_ok() {
    cf_request_return_code "$@"
    cf_check_ok $CF_CURL_RETURN_CODE
}


function cf_request_smart_silent() {
    if [[ $OPT_QUIET -eq 1 ]]; then
        local opt_silent=--silent
    else
        local opt_silent=
    fi

    cf_request_check_ok "$@" $opt_silent
}


function cf_request_put_object() {
    local container=$1
    local obj_name=$2
    local content_type=$3
    shift
    shift
    shift

    container_name=`bf_urlencode $container_name`
    obj_name=`bf_urlencode $obj_name`

    local exp=()
    if [[ $OPT_EXPIRATION -gt 0 ]]; then
        exp[0]=--header
        exp[1]="X-Delete-After: $OPT_EXPIRATION"
    fi

    cf_request_smart_silent $container/$obj_name --request PUT \
                            --header "Content-Type: $content_type" \
                            "${exp[@]}" \
                            "$@"
}


function cf_cp() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    cf_request_check_ok $src_container/$src_obj_name --silent --request COPY \
                        --header "Destination: /$dst_container/$dst_obj_name"
}


function cf_ls() {
    local container=$1
    local path=$2
    local tmp_file=$3
    local url=

    if [ -z "$path" ]; then
        url=$container
    else
        url=$container?delimiter=/\&prefix=${path}
        # Add a slash to end of prefix if it's not present because otherwise
        # CF won't return the contents of that folder
        if [ "${path: -1}" != "/" ]; then
            url=$url/
        fi
    fi

    cf_request_check_ok "${url}" --silent --output $tmp_file
}


function cf_get() {
    local container=`bf_urlencode $1`
    local filename=

    if [[ $OPT_ALL -eq 1 ]]; then
        local tmp_file=`bf_mktemp`
        # TODO: handle pagination
        # FIXME: clear container only clears containers right now, in the future
        # it would be nice if it could clear pseudo-hierarchical folders as well
        cf_ls "$container" "" $tmp_file
        local obj_names=`cat $tmp_file`
    else
        shift
        local obj_names=$@
    fi

    if [[ -n "$OPT_DIR" ]]; then
        pushd $OPT_DIR &> /dev/null
        if [[ $? -ne 0 ]]; then
            bf_die "could not change to directory '$OPT_DIR', did you create it yet?"
        fi
    fi

    # NOTE: tr -d is needed for Mac OS X, since wc -w has leading spaces
    # in output
    local total_objects=`echo $obj_names | wc -w | tr -d ' '`
    local idx=1

    for obj_name in $obj_names; do
        bf_log "Getting $idx/$total_objects objects: $obj_name"
        let idx++
        if [[ -n $OPT_OUTPUT ]]; then
            filename=$OPT_OUTPUT
        else
            filename=`basename $obj_name`
        fi
        obj_name=`bf_urlencode $obj_name`
        if [[ $filename == - ]]; then
            # Output a stream
            cf_request $container/$obj_name --silent
        else
            cf_get_file $container $obj_name $filename
        fi
    done

    if [[ -n "$OPT_DIR" ]]; then
        popd > /dev/null
    fi
    if [[ $OPT_ALL -eq 1 ]]; then
        rm $tmp_file
    fi
}


function cf_get_file() {
    local container=$1
    local obj_name=$2
    local filename=$3

    if [[ $OPT_FORCE -ne 1 ]] && [[ -e $filename ]]; then
        bf_die "File '$filename' already exists, use -f to overwrite"
    fi

    local output=.$filename.download
    local tmp_headers=`bf_mktemp`

    cf_request_smart_silent $container/$obj_name \
                            --dump-header $tmp_headers \
                            --output $output


    local etag=$(cat $tmp_headers | grep --ignore-case ^Etag \
                                  | sed 's/.*: //' \
                                  | tr -d "\r\n" \
                                  | tr -d '"')

    if [[ -z `grep --ignore-case X-Object-Manifest $tmp_headers` ]]; then
        local dlo=0
    else
        # NOTE: Dynamic Large Objects won't have an ETag that matches
        local dlo=1
    fi

    rm $tmp_headers

    if [[ $etag == $CONST_ZERO_MD5 ]]; then
        # NOTE: If it's a 0-byte file, curl will not create the output
        # file, so we have to do that ourselves
        touch $filename
        bf_warn "Zero-byte file created"
    elif [[ $dlo -eq 1 || $etag == `bf_md5 $output` ]]; then
        mv $output $filename
    else
        rm $output
        bf_die "Failed checksum validation."
    fi
}


function cf_mkdir() {
    local containers=$@
    local container=

    for container in $containers; do
        cf_request_check_ok $container --silent --output /dev/null \
                            --request PUT --upload-file /dev/null
    done
}


function cf_mv() {
    local src_container=$1
    local src_obj_name=$2
    local dst_container=$3
    local dst_obj_name=$4

    cf_cp $src_container $src_obj_name $dst_container $dst_obj_name
    cf_rm $src_container $src_obj_name
}


function cf_put_file_small() {
    local container=$1
    local filename=$2
    local obj_name=$3
    local content_type=$4
    local size=$5
    local segment_size=$6

    bf_log "Computing MD5 checksum for '$filename'..."
    local etag=`bf_md5 $filename`

    bf_log "Uploading '$obj_name' to '$container'..."
    cf_request_put_object $container $obj_name "$content_type" \
                          --header "ETag: $etag" --upload-file $filename
}


function cf_put_file_large() {
    local container=$1
    local filename=$2
    local obj_name=$3
    local content_type=$4
    local size=$5
    local segment_size=$6

    local left=$size
    local segment_num=1
    local skip=0
    local length=
    local seg_name=
    local nblocks=

    local seg_container=${obj_name}_segments
    local obj_prefix="$obj_name/`date +%s`/$size"
    local total_segments=`bf_compute_num_blocks $size $segment_size`

    cf_mkdir ${seg_container}

    while [[ $left -gt 0 ]]; do
        bf_log "Uploading segment $segment_num/$total_segments"

        if [[ $left -ge $segment_size ]]; then
            length=$segment_size
        else
            length=$left
        fi

        seg_name="$obj_prefix/`printf '%08d' $segment_num`"
        nblocks=`bf_compute_num_blocks $length $CF_DD_BLOCK_SIZE`

        dd if=$filename bs=$CF_DD_BLOCK_SIZE count=$nblocks skip=$skip \
                        2> /dev/null | \
            cf_request_put_object $seg_container $seg_name "$content_type" \
                                  --upload-file -

        let left-=$length
        let skip+=$nblocks
        let segment_num++

        bf_log ""
    done

    bf_log "Uploading manifest for ${filename}"

    local manifest="$seg_container/$obj_prefix/"
    cf_request_put_object $container $obj_name "$content_type" \
                          --data-binary '' --output /dev/null \
                          --header "X-Object-Manifest: $manifest"
}


function cf_put_file() {
    local container=$1
    local obj_name=$2

    local filename=
    local segment_size=
    local content_type=
    local size=

    if [[ -n $OPT_INPUT ]]; then
        filename=$OPT_INPUT
    else
        filename=$obj_name
    fi

    if [[ ! -e $filename ]]; then
        bf_die "File '$filename' not found"
    fi

    if [[ -n $CF_SEGMENT_SIZE ]];  then
        segment_size=$CF_SEGMENT_SIZE
    else
        segment_size=$CF_DEFAULT_SEGMENT_SIZE
    fi

    if [[ -n $OPT_CONTENT_TYPE ]]; then
        content_type=$OPT_CONTENT_TYPE
    else
        content_type=`bf_autodetect_filetype $filename`
    fi

    size=`bf_size $filename`

    if [[ $size -gt $segment_size ]]; then
        cf_put_file_large $container $filename $obj_name \
                          "$content_type" $size $segment_size
    else
        cf_put_file_small $container $filename $obj_name \
                          "$content_type" $size $segment_size
    fi
}


function cf_put_stream() {
    local container=$1
    local obj_name=$2

    local content_type=

    if [[ -n $OPT_CONTENT_TYPE ]]; then
        content_type=$OPT_CONTENT_TYPE
    else
        content_type=$BF_DEFAULT_CONTENT_TYPE
    fi

    cf_request_put_object $container $obj_name "$content_type" --upload-file -
}


function cf_put() {
    local container=$1
    shift
    local obj_names=$@

    local obj_name=
    for obj_name in $obj_names; do
        if [[ $OPT_INPUT == - ]]; then
            cf_put_stream $container $obj_name
        else
            cf_put_file $container $obj_name
        fi
    done
}


function cf_rm() {
    local container=$1
    shift
    local obj_names=$@

    local obj_name=
    for obj_name in $obj_names; do
        cf_request_check_ok $container/$obj_name --silent --request DELETE
    done
}


function cf_clear_container() {
    local container=$1
    local tmp_file=`bf_mktemp`

    # TODO: handle pagination
    # FIXME: clear container only clears containers right now, in the future
    # it would be nice if it could clear pseudo-hierarchical folders as well
    cf_ls "$container" "" $tmp_file
    local obj_names=`cat $tmp_file`

    # NOTE: tr -d is needed for Mac OS X, since wc -w has leading spaces
    # in output
    local total_objects=`echo $obj_names | wc -w | tr -d ' '`
    local idx=1

    local obj_name=
    for obj_name in $obj_names; do
        bf_log "Deleting $idx/$total_objects objects: $obj_name"
        cf_rm $container $obj_name
        let idx++
    done

    rm $tmp_file
}


function cf_rmdir() {
    # FIXME: rmdir should only take one container, and second arg should be
    # optional path
    local containers=$@

    local container=
    for container in $containers; do
        if [[ $OPT_FORCE -eq 1 ]]; then
            cf_clear_container $container
        fi

        bf_log "Deleting container: $container"
        cf_request_check_ok $container --silent --request DELETE
    done
}


function cf_stat_thing() {
    local thing=$1

    local tmp_file=`bf_mktemp`

    # NOTE: if we used --request HEAD instead of --head, curl would
    # expect Content-Length bytes to be sent as entity body which
    # would cause a timeout since HEAD requests don't result in a body
    cf_request_check_ok "$thing" --silent --output /dev/null --head \
                        --dump-header $tmp_file

    cat $tmp_file
    rm $tmp_file
}


function cf_stat() {
    local container=$1
    shift
    local obj_names=$@

    if [[ -z $obj_names ]]; then
        # Account or Container
        cf_stat_thing "$container"
    else
        # Objects
        local obj_name=
        for obj_name in $obj_names; do
            cf_stat_thing $container/$obj_name
        done
    fi
}


function cf_object_exists() {
    local container=$1
    local obj_name=$2

    cf_request_return_code $container/$obj_name --silent --output /dev/null --head

    if [[ $CF_CURL_RETURN_CODE -eq 204 ]]; then
        return 0
    elif [[ $CF_CURL_RETURN_CODE -eq 200 ]]; then
        # This appears to be a bug in CloudFiles, 200 should not be returned
        # when entity body is absent
        return 0
    elif [[ $CF_CURL_RETURN_CODE -eq 404 ]]; then
        return 1
    else
        bf_die "Invalid error code $code"
    fi
}


function cf_assert_objects_missing() {
    local container=$1
    shift
    local obj_names=$@

    local obj_name=
    for obj_name in $obj_names; do
        cf_request_return_code $container/$obj_name --silent --output /dev/null --head

        if [[ $CF_CURL_RETURN_CODE -eq 200 || $CF_CURL_RETURN_CODE -eq 204 ]]; then
            # The fact that CloudFiles returns a 200 here even though there is
            # no entity body is a bug per the HTTP spec, should be 204
            # instead.
            bf_die "Object '$obj_name' already exists, use -f to overwrite"
        elif [[ $CF_CURL_RETURN_CODE -eq 404 ]]; then
            continue
        else
            bf_die "Invalid error code $code"
        fi
    done
}


function cf_save_endpoint_config() {
    cat >> $BF_ENDPOINT_CONFIG <<EOF
CF_USER=$CF_USER
CF_API_KEY=$CF_API_KEY
CF_AUTH_URL=$CF_AUTH_URL
CF_SERVICENET=$CF_SERVICENET
CF_INSECURE=$CF_INSECURE
CF_TMPLINK_CONTAINER=$CF_TMPLINK_CONTAINER
EOF
}


function cf_load_endpoint_config_interactive() {
    local ret=1

    if [[ -n $CF_USER && -n $CF_API_KEY ]]; then
        # If CF_USER and CF_API_KEY are set then we don't need interactive
        # mode
        return $ret
    fi

    if [[ -z $CF_USER ]]; then
        ret=0
        bf_ask_required 'CF_USER' 'CloudFiles Username:'
    fi

    if [[ -z $CF_API_KEY ]]; then
        ret=0
        bf_ask_required 'CF_API_KEY' 'CloudFiles API Key:'
    fi

    if [[ -z $CF_AUTH_URL ]]; then
        ret=0
        local auth_url=$(bf_ask_with_default us \
                         'Location or Auth URL [<url>/uk/US]:')

        if [[ $auth_url == 'uk' || $auth_url == 'UK' ]]; then
            CF_AUTH_URL=$CF_DEFAULT_AUTH_URL_UK
        elif [[ $auth_url == 'us' || $auth_url == 'US' ]]; then
            CF_AUTH_URL=$CF_DEFAULT_AUTH_URL_US
        else
            CF_AUTH_URL=$auth_url
        fi
    fi

    if [[ -z $CF_SERVICENET ]]; then
        ret=0
        CF_SERVICENET=`bf_ask_yes_no n 'Use ServiceNET'`
    fi

    if [[ -z $CF_INSECURE ]]; then
        ret=0
        CF_INSECURE=`bf_ask_yes_no n 'Allow Insecure SSL'`
    fi

    return $ret
}


#############################################################################
#                                                                           #
#                           CloudFiles CDN                                  #
#                                                                           #
#############################################################################

CF_CDN_HOST_DFW=cdn1.clouddrive.com
CF_CDN_HOST_ORD=cdn2.clouddrive.com
CF_CDN_HOST_LON=cdn3.clouddrive.com
CF_CDN_HOST_SYD=cdn4.clouddrive.com
CF_CDN_HOST_IAD=cdn5.clouddrive.com
CF_CDN_HOST_HKG=cdn6.clouddrive.com


function cf_cdn_request_return_code() {
    local region=$1
    local url=$2
    shift
    shift

    case $region in
        dfw)    host=$CF_CDN_HOST_DFW;;
        ord)    host=$CF_CDN_HOST_ORD;;
        lon)    host=$CF_CDN_HOST_LON;;
        syd)    host=$CF_CDN_HOST_SYD;;
        iad)    host=$CF_CDN_HOST_IAD;;
        hkg)    host=$CF_CDN_HOST_HKG;;
        *)      bf_die "Unknown region: $region";;
    esac

    cf_auth
    local cdn_url=${CF_STORAGE_URL/:\/\/storage*.com/:\/\/$host}

    cf_curl_return_code "$cdn_url/$url" \
                        --header "X-Auth-Token: $CF_AUTH_TOKEN" \
                        "$@"
}


function cf_cdn_request_check_ok() {
    cf_cdn_request_return_code "$@"
    cf_check_ok $CF_CURL_RETURN_CODE
}


function cf_cdn_find_region_for_container() {
    local container=$1

    local region=
    local tmp_file=`bf_mktemp`

    for region in iad dfw ord lon syd hkg; do
        cf_cdn_ls $region "$tmp_file"
        grep $container < $tmp_file > /dev/null 2> /dev/null
        local ret=$?
        if [[ $ret -eq 0 ]]; then
            break
        fi
    done

    echo $region

    rm $tmp_file
}


function cf_cdn_modify() {
    local region=$1
    local container=$2
    shift
    shift

    cf_cdn_request_check_ok $region $container \
                            --output /dev/null \
                            --silent\
                            --request PUT \
                            "$@"
}


function cf_cdn_disable() {
    local region=$1
    local container=$2

    cf_cdn_modify $region $container \
                  --header "X-CDN-Enabled: False"
}


function cf_cdn_enable() {
    local region=$1
    local container=$2

    cf_cdn_modify $region $container \
                  --header "X-CDN-Enabled: True"
}


function cf_cdn_ls() {
    local region=$1
    local tmp_file=$2

    cf_cdn_request_check_ok $region "" --silent --output $tmp_file
}


function cf_cdn_stat() {
    local region=$1
    local container=$2
    local tmp_file=$3

    # NOTE: if we used --request HEAD instead of --head, curl would
    # expect Content-Length bytes to be sent as entity body which
    # would cause a timeout since HEAD requests don't result in a body
    cf_cdn_request_check_ok $region $container --silent \
                            --output /dev/null --head \
                            --dump-header $tmp_file
}



#############################################################################
#                                                                           #
#                                    Main                                   #
#                                                                           #
#############################################################################


while getopts 'abd:e:fhi:o:qt:vx:' opt; do
    case $opt in
        a) OPT_ALL=1;;
        b) bf_bash_completion;;
        d) OPT_DIR=$OPTARG;;
        e) OPT_ENDPOINT=$OPTARG;;
        f) OPT_FORCE=1;;
        h) bf_help;;
        i) OPT_INPUT=$OPTARG;;
        o) OPT_OUTPUT=$OPTARG;;
        q) OPT_QUIET=1;;
        t) OPT_CONTENT_TYPE=$OPTARG;;
        v) bf_version;;
        x) OPT_EXPIRATION=$OPTARG;;
        *) bf_general_usage;;
    esac
done
shift $(($OPTIND - 1))
cmd=$1
shift
case $cmd in
    cdn)        cmd_cdn         $@;;
    cp)         cmd_cp          $@;;
    endpoint)   cmd_endpoint    $@;;
    ls)         cmd_ls          $@;;
    get)        cmd_get         $@;;
    mkdir)      cmd_mkdir       $@;;
    mv)         cmd_mv          $@;;
    put)        cmd_put         $@;;
    rm)         cmd_rm          $@;;
    rmdir)      cmd_rmdir       $@;;
    stat)       cmd_stat        $@;;
    tmplink)    cmd_tmplink     $@;;
    *)      bf_general_usage;;
esac
